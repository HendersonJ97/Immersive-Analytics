<!DOCTYPE html>
<meta charset="utf-8">

<head>
  <script src="https://d3js.org/d3.v3.min.js"></script>
  <script src="https://aframe.io/releases/0.6.1/aframe.min.js"></script>
</head>

<body style='margin : 0px; overflow: hidden;'>

  <script>
    var width = 960,
      height = 500;

    var x = d3.scale.ordinal()
      .rangePoints([0, width], 1),
      y = {},
      dragging = {};

    var line = d3.svg.line();
    var background, foreground;

    var csvData;
    var names;

    var offsetx = 500;
    var zOffset = 0;

    d3.csv("cars.csv", function(cars) {
      // Store data
      csvData = cars;
      csvData.map(function(d) {
        return +d;
      });
      // Generate axes
      // Delete old axis (if they exist)
      d3.select("a-scene").selectAll("a-datum").remove();
      // Generate column position scale
      names = d3.keys(cars[0]).filter(function(column_name) {
        return column_name != "name";
      })
      var xScale = d3.scale.linear();
      xScale.range([0, width]);
      xScale.domain([0, (names.length - 1)]);

      d3.select("a-scene").selectAll("a-axis")
        .data(names)
        .enter()
        .append("a-axis")
        .each(function(datum, index) {
          // Select itself
          var entity = d3.select(this);
          var boundaries = d3.extent(cars, function(max_values) {
            return +max_values[datum];
          });

          console.log("Creating axis at x=" + xScale(index) + " using " + index + " for " + datum);
          console.log("Boundardies: " + boundaries);

          // Set attributes
          entity.attr("name", datum);
          entity.attr("positionorder", index);
          entity.attr("positionx", xScale(index));
          entity.attr("positionz", zOffset);
          entity.attr("height", height);
          entity.attr("minvalue", boundaries[0]);
          entity.attr("maxvalue", boundaries[1]);
        });

      // Generate Lines
      //for (i = 0; i < names.length - 2; i++) {
      //  generateLines(i);
      //}

      //generateLines(0);
      //generateLines(1);
      //generateLines(2);
      //generateLines(3);
      //generateLines(4);
      //generateLines(5);
      /*
            x.domain(dimensions = d3.keys(cars[0]) // get column names (leaving as global)
              .filter(function(column_name) {
                return column_name != "name" && (y[column_name] = d3.scale.linear() // Discard names
                  .domain(d3.extent(cars, function(max_values) { // create scale from max column values
                    return +max_values[column_name]
                  }))
                  .range([height, 0]))
              }));*/
      /*
            var lines = d3.select("a-scene").selectAll("a-entity")
              .data(cars)
              .enter()
              .append("a-entity")
              .each(function(datum, index) {
                // Select itself
                var entity = d3.select(this);
                var coordinates = dimensions.map(function(column_name) {
                  return [x(column_name), y[column_name](datum[column_name])];
                });
                //console.log("coords", coordinates);
                // Loop for each dimension
                for (i = 0; i < coordinates.length - 1; i++) {
                  var value = "start: " + offsetx + " " + coordinates[i][1] + " " + (coordinates[i][0] + offsetz) +
                    "; end: " + offsetx + " " + coordinates[i + 1][1] + " " + (coordinates[i + 1][0] + offsetz) +
                    "; color: red";
                  //console.log("lines", value);
                  entity.attr("line__" + (i + 1), value);
                }
              })
      */
      /*
              var plane = d3.select("a-scene")
                .append("a-plane")
                .attr("position", offsetx + " " + 0 + " " + x(dimensions[0]))
                .attr("height", height)
                .attr("width", width);
      */
    })

    function generateLines(sector) {
      if (sector < 0) {
        // No section here
        return 0;
      }

      // eg section 1: axes 1 to 2
      // Retrieve axes of section
      var leftAxis = d3.select("a-scene").select("a-axis[positionorder='" + sector + "']");
      var rightAxis = d3.select("a-scene").select("a-axis[positionorder='" + (sector + 1) + "']");

      // Check if at right edge
      if (rightAxis.empty()) {
        // No section here
        return 0;
      }

      // Generate y-scale for left axis
      var leftYScale = d3.scale.linear();
      leftYScale.domain([leftAxis.attr("minvalue"), leftAxis.attr("maxvalue")]);
      leftYScale.range([leftAxis.attr("height"), 0]);

      // Generate y-scale for right axis
      var rightYScale = d3.scale.linear();
      rightYScale.domain([rightAxis.attr("minvalue"), rightAxis.attr("maxvalue")]);
      rightYScale.range([rightAxis.attr("height"), 0]);

      // Remove old lines
      d3.select("a-scene").selectAll("a-datum[sector='" + sector + "']").remove();

      console.log("Generating lines for sector: " + sector);

      // Generate new Lines
      d3.select("a-scene").selectAll("a-datum[sector='" + sector + "']")
        .data(csvData)
        .enter()
        .append("a-datum")
        .each(function(datum, index) {
          // Select itself
          var entity = d3.select(this);
          // offsetx(from axes) + scale(datum[sector]) + offsetz(from axes)
          var firstCoord = leftAxis.attr("positionx") + " " + leftYScale(datum[leftAxis.attr("name")]) + " " + leftAxis.attr("positionz");
          var secondCoord = rightAxis.attr("positionx") + " " + rightYScale(datum[rightAxis.attr("name")]) + " " + rightAxis.attr("positionz");

          //console.log("Creating line, first coord: " + firstCoord + " ; second coord: " + secondCoord);
          //console.log("Sector: " + parseInt(sector));
          //console.log("leftAxis order: " + leftAxis.attr("positionorder"));
          //console.log("datum: " + datum);
          //console.log("datum[leftAxis name]: " + datum[leftAxis.attr("name")]);
          //console.log("datum[rightAxis name]: " + datum[rightAxis.attr("name")]);
          //console.log("leftYScale(datum[left name]): " + leftYScale(datum[leftAxis.attr("name")]));
          //console.log("rightYScale(datum[right name]): " + rightYScale(datum[rightAxis.attr("name")]));

          // Set attributes
          entity.attr("firstcoord", firstCoord);
          entity.attr("secondcoord", secondCoord);
          entity.attr("sector", leftAxis.attr("positionorder"));
        });
    }

    function isEqualVec3(a, b) {
      if (!a || !b) {
        return false;
      }
      return (a.x === b.x && a.y === b.y && a.z === b.z);
    }

    /**
      Represents one axis
    */
    AFRAME.registerComponent('axis', {
      schema: {
        colour: {
          default: '#FFF'
        },
        name: {
          type: 'string',
          default: ''
        },
        positionOrder: {
          type: 'int',
          default: 1
        },
        positionX: {
          type: 'number',
          default: 1
        },
        positionZ: {
          type: 'number',
          default: 1
        },
        height: {
          type: 'number',
          default: height
        },
        maxValue: {
          type: 'number',
          default: height
        },
        minValue: {
          type: 'number',
          default: 0
        },
        thickness: {
          type: 'int',
          default: 1
        }
      },

      init: function() {
        var data = this.data;
        var geometry;
        var material;

        material = this.material = new THREE.LineBasicMaterial({
          color: data.colour,
          opacity: 1,
          transparent: 0,
          visible: true
        });

        geometry = this.geometry = new THREE.BufferGeometry();
        geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(2 * 3), 3));

        this.line = new THREE.Line(geometry, material);
        this.el.setObject3D(this.attrName, this.line);
      },

      update: function(oldData) {
        // On property update (and after init)
        var data = this.data; // Property values
        var geometry = this.geometry;
        var geoNeedsUpdate = false;
        var material = this.material;
        var positionArray = geometry.attributes.position.array;

        // Geometry change
        if (data.positionX !== oldData.positionX ||
          data.positionZ !== oldData.positionZ) {
          // Check for overlap
          var prevAxis = d3.select("a-scene").select("a-axis[positionorder='" + (data.positionOrder - 1) + "']");
          var nextAxis = d3.select("a-scene").select("a-axis[positionorder='" + (data.positionOrder + 1) + "']");

          // Check for order changes
          if (!prevAxis.empty() && (data.positionX < prevAxis.attr("positionx") ||
              data.positionZ < prevAxis.attr("positionz"))) {
            // Axis has been moved down the list
            // Swap prevAxis' positionOrder
            prevAxis.attr("positionorder", data.positionOrder);
            // Decrement positionOrder
            var thisAxis =  d3.select("a-scene").select("a-axis[name='" + data.name + "']");
            thisAxis.attr("positionorder", data.positionOrder - 1);
            data.positionOrder--;
          } else if (!nextAxis.empty() && (data.positionX > nextAxis.attr("positionx") ||
              data.positionZ > nextAxis.attr("positionz"))) {
            // Axis has been moved up the list
            // Swap nextAxis' positionOrder
            nextAxis.attr("positionorder", data.positionOrder);
            // Increment positionOrder
            var thisAxis =  d3.select("a-scene").select("a-axis[name='" + data.name + "']");
            thisAxis.attr("positionorder", data.positionOrder + 1);
            data.positionOrder++;
          }

          // Update lines
          if (data.positionOrder == 0) {
            // Start
            generateLines(0);
            generateLines(1);
          } else if (data.positionOrder == names.length - 1) {
            // End
            generateLines(data.positionOrder - 1);
            generateLines(data.positionOrder - 2);
          } else {
            // Middle
            for (i = (data.positionOrder - 2); i < data.positionOrder + 3; i++) {
              generateLines(i);
            }
          }

          // Reset mesh
          positionArray[0] = data.positionX;
          positionArray[1] = 0;
          positionArray[2] = data.positionZ;
          positionArray[3] = data.positionX;
          positionArray[4] = data.height;
          positionArray[5] = data.positionZ;
          
          geometry.attributes.needsUpdate = true;
-         geometry.computeBoundingSphere();
        }
      },

      remove: function() {
        this.el.removeObject3D('line', this.line);
      }
    })

    /**
      Represents one axis
    */
    AFRAME.registerComponent('datum', {
      schema: {
        colour: {
          default: '#FFF'
        },
        sector: {
          type: 'int',
          default: 0
        },
        thickness: {
          type: 'int',
          default: 1
        },
        firstCoord: {
          type: 'vec3',
          default: {
            x: 0,
            y: 0,
            z: 0
          }
        },
        secondCoord: {
          type: 'vec3',
          default: {
            x: 0,
            y: 0,
            z: 0
          }
        }
      },

      init: function() {
        var data = this.data;
        var geometry;
        var material;

        material = this.material = new THREE.LineBasicMaterial({
          color: data.colour,
          opacity: 1,
          transparent: 0,
          visible: true
        });

        geometry = this.geometry = new THREE.BufferGeometry();
        geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(2 * 3), 3));

        this.line = new THREE.Line(geometry, material);
        this.el.setObject3D(this.attrName, this.line);
      },

      update: function(oldData) {
        // On property update (and after init)
        var data = this.data; // Property values
        var geometry = this.geometry;
        var geoNeedsUpdate = false;
        var material = this.material;
        var positionArray = geometry.attributes.position.array;

        // Update Geometry
        if (!isEqualVec3(data.firstCoord, oldData.firstCoord)) {
          positionArray[0] = data.firstCoord.x;
          positionArray[1] = data.firstCoord.y;
          positionArray[2] = data.firstCoord.z;
          geoNeedsUpdate = true;
        }

        if (!isEqualVec3(data.secondCoord, oldData.secondCoord)) {
          positionArray[3] = data.secondCoord.x;
          positionArray[4] = data.secondCoord.y;
          positionArray[5] = data.secondCoord.z;
          geoNeedsUpdate = true;
        }

        if (geoNeedsUpdate) {
          geometry.attributes.needsUpdate = true;
          geometry.computeBoundingSphere();
        }

        material.color.setStyle(data.colour);
        material.opacity = 1;
        material.transparent = 0;
        material.visible = true;
      },

      remove: function() {
        this.el.removeObject3D('line', this.line);
      }
    })

    AFRAME.registerPrimitive('a-axis', {
      // Attaches 'axis' to 'a-axis'
      defaultComponents: {
        axis: {}
      },

      mappings: {
        colour: 'axis.colour',
        name: 'axis.name',
        positionorder: 'axis.positionOrder',
        positionx: 'axis.positionX',
        positionz: 'axis.positionZ',
        height: 'axis.height',
        maxvalue: 'axis.maxValue',
        minvalue: 'axis.minValue',
        thickness: 'axis.thickness'
      }
    })

    AFRAME.registerPrimitive('a-datum', {
      // Attaches 'axis' to 'a-axis'
      defaultComponents: {
        datum: {}
      },

      mappings: {
        colour: 'datum.colour',
        sector: 'datum.sector',
        thickness: 'datum.thickess',
        firstcoord: 'datum.firstCoord',
        secondcoord: 'datum.secondCoord'
      }
    })
  </script>
  <a-scene>
    <a-assets>
      <img id="ground" src="ground.png">
    </a-assets>
    <a-camera look-controls wasd-controls='easing:10'>
      <a-cursor></a-cursor>
    </a-camera>
    <a-sky color='#4CC3D9' fuse timeout='100'></a-sky>
    <a-plane color='#CCC' height="500" width="500" rotation="-90 0 0"></a-plane>
  </a-scene>
</body>

</html>
